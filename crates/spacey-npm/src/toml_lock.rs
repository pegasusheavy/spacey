//! TOML-based lockfile (snpm.toml).
//!
//! A human-readable, diff-friendly lockfile format inspired by Cargo.lock.
//!
//! # Format
//!
//! ```toml
//! # This file is automatically generated by snpm.
//! # It is not intended for manual editing.
//!
//! [metadata]
//! version = 1
//! generated = "2024-01-15T10:30:00Z"
//!
//! [root]
//! name = "my-project"
//! version = "1.0.0"
//!
//! [[package]]
//! name = "lodash"
//! version = "4.17.21"
//! integrity = "sha512-..."
//! resolved = "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz"
//!
//! [[package]]
//! name = "express"
//! version = "4.18.2"
//! integrity = "sha512-..."
//! resolved = "https://registry.npmjs.org/express/-/express-4.18.2.tgz"
//! dependencies = ["body-parser@1.20.2", "cookie@0.5.0"]
//! ```

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::path::Path;
use chrono::{DateTime, Utc};

use crate::error::{Result, SnpmError};
use crate::resolver::ResolvedPackage;

/// Current lockfile format version.
const LOCKFILE_VERSION: u32 = 1;

/// TOML lockfile (snpm.toml).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnpmToml {
    /// Lockfile metadata
    pub metadata: LockMetadata,
    /// Root package information
    pub root: RootPackage,
    /// Locked packages
    #[serde(default, rename = "package")]
    pub packages: Vec<LockedPackage>,
}

/// Lockfile metadata.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockMetadata {
    /// Lockfile format version
    pub version: u32,
    /// When the lockfile was generated
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generated: Option<String>,
    /// snpm version that generated this file
    #[serde(skip_serializing_if = "Option::is_none")]
    pub snpm_version: Option<String>,
}

/// Root package information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RootPackage {
    /// Package name
    pub name: String,
    /// Package version
    pub version: String,
    /// Direct dependencies
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub dependencies: Vec<String>,
    /// Direct dev dependencies
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub dev_dependencies: Vec<String>,
    /// Direct optional dependencies
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub optional_dependencies: Vec<String>,
}

/// A locked package entry.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub struct LockedPackage {
    /// Package name
    pub name: String,
    /// Exact version
    pub version: String,
    /// Integrity hash (SRI format)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integrity: Option<String>,
    /// Resolved URL
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolved: Option<String>,
    /// Dependencies as "name@version" strings
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub dependencies: Vec<String>,
    /// Peer dependencies as "name@version" strings
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub peer_dependencies: Vec<String>,
    /// Optional dependencies as "name@version" strings
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub optional_dependencies: Vec<String>,
    /// Whether this is a dev dependency
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub dev: bool,
    /// Whether this is optional
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub optional: bool,
    /// Whether this package has install scripts
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub has_install_script: bool,
    /// OS restrictions
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub os: Vec<String>,
    /// CPU restrictions
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub cpu: Vec<String>,
    /// Node.js engine requirement
    #[serde(skip_serializing_if = "Option::is_none")]
    pub engines_node: Option<String>,
}

impl SnpmToml {
    /// Create a new lockfile.
    pub fn new(name: String, version: String) -> Self {
        Self {
            metadata: LockMetadata {
                version: LOCKFILE_VERSION,
                generated: Some(Utc::now().to_rfc3339()),
                snpm_version: Some(env!("CARGO_PKG_VERSION").to_string()),
            },
            root: RootPackage {
                name,
                version,
                dependencies: vec![],
                dev_dependencies: vec![],
                optional_dependencies: vec![],
            },
            packages: vec![],
        }
    }

    /// Read a lockfile from disk.
    pub fn read<P: AsRef<Path>>(path: P) -> Result<Self> {
        let content = std::fs::read_to_string(path.as_ref())?;
        Self::parse(&content)
    }

    /// Parse a lockfile from a string.
    pub fn parse(content: &str) -> Result<Self> {
        toml::from_str(content).map_err(|e| SnpmError::InvalidLockfile(e.to_string()))
    }

    /// Write the lockfile to disk.
    pub fn write<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let content = self.to_toml_string()?;
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Convert to TOML string with header comment.
    pub fn to_toml_string(&self) -> Result<String> {
        let toml_content = toml::to_string_pretty(self)
            .map_err(|e| SnpmError::InvalidLockfile(e.to_string()))?;

        let header = r#"# This file is automatically generated by snpm.
# It is not intended for manual editing.
#
# To update, run: snpm install
# To regenerate from scratch: rm snpm.toml && snpm install

"#;

        Ok(format!("{}{}", header, toml_content))
    }

    /// Add a package to the lockfile.
    pub fn add_package(&mut self, pkg: LockedPackage) {
        // Remove existing entry if present
        self.packages.retain(|p| p.name != pkg.name || p.version != pkg.version);
        self.packages.push(pkg);
        self.sort_packages();
    }

    /// Remove a package from the lockfile.
    pub fn remove_package(&mut self, name: &str) -> bool {
        let len_before = self.packages.len();
        self.packages.retain(|p| p.name != name);
        self.packages.len() != len_before
    }

    /// Get a locked package by name and version.
    pub fn get_package(&self, name: &str, version: &str) -> Option<&LockedPackage> {
        self.packages.iter().find(|p| p.name == name && p.version == version)
    }

    /// Get the latest locked version of a package.
    pub fn get_latest_version(&self, name: &str) -> Option<&LockedPackage> {
        self.packages.iter().filter(|p| p.name == name).last()
    }

    /// Check if a package is locked.
    pub fn is_locked(&self, name: &str, version: &str) -> bool {
        self.packages.iter().any(|p| p.name == name && p.version == version)
    }

    /// Sort packages alphabetically for consistent output.
    fn sort_packages(&mut self) {
        self.packages.sort();
    }

    /// Set root package dependencies.
    pub fn set_root_dependencies(
        &mut self,
        deps: Vec<String>,
        dev_deps: Vec<String>,
        optional_deps: Vec<String>,
    ) {
        self.root.dependencies = deps;
        self.root.dev_dependencies = dev_deps;
        self.root.optional_dependencies = optional_deps;
    }

    /// Update metadata timestamp.
    pub fn touch(&mut self) {
        self.metadata.generated = Some(Utc::now().to_rfc3339());
    }

    /// Convert from resolved packages.
    pub fn from_resolved(
        name: String,
        version: String,
        packages: &[ResolvedPackage],
    ) -> Self {
        let mut lockfile = Self::new(name, version);

        // Categorize root dependencies
        let mut deps = vec![];
        let mut dev_deps = vec![];
        let mut opt_deps = vec![];

        for pkg in packages {
            // Add to root dependencies list
            let dep_str = format!("{}@{}", pkg.name, pkg.version);
            match pkg.dep_type {
                crate::package::DependencyType::Production => deps.push(dep_str),
                crate::package::DependencyType::Development => dev_deps.push(dep_str),
                crate::package::DependencyType::Optional => opt_deps.push(dep_str),
                crate::package::DependencyType::Peer => {} // Peer deps handled separately
            }

            // Create locked package entry
            let locked = LockedPackage {
                name: pkg.name.clone(),
                version: pkg.version.clone(),
                integrity: pkg.integrity.clone(),
                resolved: Some(pkg.tarball_url.clone()),
                dependencies: pkg
                    .dependencies
                    .iter()
                    .map(|(k, v)| format!("{}@{}", k, v))
                    .collect(),
                peer_dependencies: pkg
                    .peer_dependencies
                    .iter()
                    .map(|(k, v)| format!("{}@{}", k, v))
                    .collect(),
                optional_dependencies: pkg
                    .optional_dependencies
                    .iter()
                    .map(|(k, v)| format!("{}@{}", k, v))
                    .collect(),
                dev: matches!(pkg.dep_type, crate::package::DependencyType::Development),
                optional: pkg.optional,
                has_install_script: pkg.has_install_script,
                os: vec![],
                cpu: vec![],
                engines_node: None,
            };

            lockfile.add_package(locked);
        }

        // Sort dependency lists
        deps.sort();
        dev_deps.sort();
        opt_deps.sort();

        lockfile.set_root_dependencies(deps, dev_deps, opt_deps);

        lockfile
    }

    /// Get all package identifiers (name@version).
    pub fn package_ids(&self) -> Vec<String> {
        self.packages
            .iter()
            .map(|p| format!("{}@{}", p.name, p.version))
            .collect()
    }

    /// Validate the lockfile structure.
    pub fn validate(&self) -> Result<()> {
        // Check version
        if self.metadata.version > LOCKFILE_VERSION {
            return Err(SnpmError::InvalidLockfile(format!(
                "Lockfile version {} is newer than supported version {}",
                self.metadata.version, LOCKFILE_VERSION
            )));
        }

        // Check for duplicate packages
        let mut seen = std::collections::HashSet::new();
        for pkg in &self.packages {
            let id = format!("{}@{}", pkg.name, pkg.version);
            if !seen.insert(id.clone()) {
                return Err(SnpmError::InvalidLockfile(format!(
                    "Duplicate package: {}",
                    id
                )));
            }
        }

        Ok(())
    }

    /// Diff with another lockfile.
    pub fn diff(&self, other: &SnpmToml) -> LockfileDiff {
        let self_ids: std::collections::HashSet<_> = self.package_ids().into_iter().collect();
        let other_ids: std::collections::HashSet<_> = other.package_ids().into_iter().collect();

        let added: Vec<_> = other_ids.difference(&self_ids).cloned().collect();
        let removed: Vec<_> = self_ids.difference(&other_ids).cloned().collect();

        // Find updated packages (same name, different version)
        let mut updated = vec![];
        let self_by_name: BTreeMap<_, _> = self.packages.iter().map(|p| (&p.name, &p.version)).collect();
        let other_by_name: BTreeMap<_, _> = other.packages.iter().map(|p| (&p.name, &p.version)).collect();

        for (name, old_version) in &self_by_name {
            if let Some(new_version) = other_by_name.get(name) {
                if old_version != new_version {
                    updated.push(PackageUpdate {
                        name: (*name).clone(),
                        old_version: (*old_version).clone(),
                        new_version: (*new_version).clone(),
                    });
                }
            }
        }

        LockfileDiff {
            added,
            removed,
            updated,
        }
    }
}

impl Default for SnpmToml {
    fn default() -> Self {
        Self::new("unnamed".to_string(), "0.0.0".to_string())
    }
}

/// Difference between two lockfiles.
#[derive(Debug, Clone)]
pub struct LockfileDiff {
    /// Added packages (name@version)
    pub added: Vec<String>,
    /// Removed packages (name@version)
    pub removed: Vec<String>,
    /// Updated packages
    pub updated: Vec<PackageUpdate>,
}

impl LockfileDiff {
    /// Check if there are any changes.
    pub fn is_empty(&self) -> bool {
        self.added.is_empty() && self.removed.is_empty() && self.updated.is_empty()
    }

    /// Get total number of changes.
    pub fn len(&self) -> usize {
        self.added.len() + self.removed.len() + self.updated.len()
    }
}

/// A package version update.
#[derive(Debug, Clone)]
pub struct PackageUpdate {
    /// Package name
    pub name: String,
    /// Old version
    pub old_version: String,
    /// New version
    pub new_version: String,
}

/// Convert a JSON package-lock.json to snpm.toml format.
pub fn convert_from_package_lock(package_lock: &crate::lockfile::PackageLock) -> SnpmToml {
    let mut lockfile = SnpmToml::new(
        package_lock.name.clone(),
        package_lock.version.clone(),
    );

    for (path, pkg) in &package_lock.packages {
        // Skip root package entry
        if path.is_empty() {
            continue;
        }

        // Extract package name from path (node_modules/name or node_modules/@scope/name)
        let name = path
            .strip_prefix("node_modules/")
            .unwrap_or(path)
            .to_string();

        let locked = LockedPackage {
            name,
            version: pkg.version.clone(),
            integrity: pkg.integrity.clone(),
            resolved: pkg.resolved.clone(),
            dependencies: pkg
                .dependencies
                .iter()
                .map(|(k, v)| format!("{}@{}", k, v))
                .collect(),
            peer_dependencies: pkg
                .peer_dependencies
                .iter()
                .map(|(k, v)| format!("{}@{}", k, v))
                .collect(),
            optional_dependencies: pkg
                .optional_dependencies
                .iter()
                .map(|(k, v)| format!("{}@{}", k, v))
                .collect(),
            dev: pkg.dev,
            optional: pkg.optional,
            has_install_script: pkg.has_install_script,
            os: vec![],
            cpu: vec![],
            engines_node: pkg.engines.get("node").cloned(),
        };

        lockfile.add_package(locked);
    }

    lockfile
}

/// Convert snpm.toml to package-lock.json format.
pub fn convert_to_package_lock(snpm_toml: &SnpmToml) -> crate::lockfile::PackageLock {
    use crate::lockfile::{LockPackage, PackageLock};

    let mut package_lock = PackageLock::new(
        snpm_toml.root.name.clone(),
        snpm_toml.root.version.clone(),
    );

    // Add root package entry
    package_lock.add_package(
        "",
        LockPackage {
            version: snpm_toml.root.version.clone(),
            dependencies: parse_dep_strings(&snpm_toml.root.dependencies),
            dev_dependencies: parse_dep_strings(&snpm_toml.root.dev_dependencies),
            optional_dependencies: parse_dep_strings(&snpm_toml.root.optional_dependencies),
            ..Default::default()
        },
    );

    // Add all packages
    for pkg in &snpm_toml.packages {
        let path = format!("node_modules/{}", pkg.name);
        let mut engines = std::collections::BTreeMap::new();
        if let Some(ref node) = pkg.engines_node {
            engines.insert("node".to_string(), node.clone());
        }

        package_lock.add_package(
            &path,
            LockPackage {
                version: pkg.version.clone(),
                resolved: pkg.resolved.clone(),
                integrity: pkg.integrity.clone(),
                dependencies: parse_dep_strings(&pkg.dependencies),
                peer_dependencies: parse_dep_strings(&pkg.peer_dependencies),
                optional_dependencies: parse_dep_strings(&pkg.optional_dependencies),
                dev: pkg.dev,
                optional: pkg.optional,
                has_install_script: pkg.has_install_script,
                engines,
                ..Default::default()
            },
        );
    }

    package_lock
}

/// Parse dependency strings ("name@version") into a map.
fn parse_dep_strings(deps: &[String]) -> BTreeMap<String, String> {
    deps.iter()
        .filter_map(|s| {
            // Handle scoped packages: @scope/name@version
            if s.starts_with('@') {
                // Find the second @ which separates name from version
                let rest = &s[1..];
                if let Some(at_pos) = rest.find('@') {
                    let name = &s[..at_pos + 1];
                    let version = &rest[at_pos + 1..];
                    return Some((name.to_string(), version.to_string()));
                }
            } else if let Some(at_pos) = s.find('@') {
                let name = &s[..at_pos];
                let version = &s[at_pos + 1..];
                return Some((name.to_string(), version.to_string()));
            }
            None
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_lockfile() {
        let lockfile = SnpmToml::new("test-project".into(), "1.0.0".into());
        assert_eq!(lockfile.root.name, "test-project");
        assert_eq!(lockfile.metadata.version, LOCKFILE_VERSION);
    }

    #[test]
    fn test_add_package() {
        let mut lockfile = SnpmToml::new("test".into(), "1.0.0".into());

        lockfile.add_package(LockedPackage {
            name: "lodash".into(),
            version: "4.17.21".into(),
            integrity: Some("sha512-xyz".into()),
            resolved: Some("https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz".into()),
            dependencies: vec![],
            peer_dependencies: vec![],
            optional_dependencies: vec![],
            dev: false,
            optional: false,
            has_install_script: false,
            os: vec![],
            cpu: vec![],
            engines_node: None,
        });

        assert!(lockfile.is_locked("lodash", "4.17.21"));
    }

    #[test]
    fn test_parse_dep_strings() {
        let deps = vec![
            "lodash@4.17.21".to_string(),
            "@types/node@18.0.0".to_string(),
        ];

        let map = parse_dep_strings(&deps);
        assert_eq!(map.get("lodash"), Some(&"4.17.21".to_string()));
        assert_eq!(map.get("@types/node"), Some(&"18.0.0".to_string()));
    }

    #[test]
    fn test_to_toml_string() {
        let mut lockfile = SnpmToml::new("test".into(), "1.0.0".into());
        lockfile.add_package(LockedPackage {
            name: "lodash".into(),
            version: "4.17.21".into(),
            integrity: Some("sha512-xyz".into()),
            resolved: None,
            dependencies: vec![],
            peer_dependencies: vec![],
            optional_dependencies: vec![],
            dev: false,
            optional: false,
            has_install_script: false,
            os: vec![],
            cpu: vec![],
            engines_node: None,
        });

        let toml_str = lockfile.to_toml_string().unwrap();
        assert!(toml_str.contains("[[package]]"));
        assert!(toml_str.contains("name = \"lodash\""));
    }
}



